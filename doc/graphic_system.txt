

Adonthell Graphic System

Alexandre Courbot

1 Goal of this document

This document is to explain the principles of the graphic system, it's
use and it's capabalities so developers can quickly develop using
it.

2 Principles

2.1 The image class

The image class is the base class. It just contain information about:

* the size of the image,

* it's depth (actually it's most likely always the same than the screen's
  depth),

* it's parameters (translucency, mask),

* the image's data, as an SDL surface.

2.1.1 Declaring and resizing an image

Two constructors can be used:

image(); 

image (u_int16 l, u_int16 h);

The first one simply declare an empty image with no data inside ; the
second allow you to specify the length and height of the image.

When you need to reset your image, call

void clear();

After calling this function your image will be reinitialized, and it's
length and height reseted to 0.

To resize it, call

void resize(u_int16 l, u_int16 h);

Keep in mind that when the function returns, your image's data are
totally erased. If you want to scale the image, rather call the zoom
function.

2.1.2 Loading an image

Images are currently encoded as PNM files. To load a PNM into an image,
simply call

s_int8 image::load(char * fname);

or

s_int8 image::get(SDL_RWops * file);

to get a PNM encoded image from an open file.

2.1.3 Displaying an image

There are two ways to display images, choose the one that fits better
to your needs.

Using the draw function

Before displaying an image, you should first set it's properties (usually
you'll do this at load time):

bool get_mask(); 

void set_mask(bool m); 

u_int8 get_trans(); 

void set_trans(u_int8 t);

These functions allow you to set and get the mask parameter (whether
the pink 0xFF00FF color is displayed or not) and translucency parameter,
0 being totally opaque (no translucency) and 255 totally translucent.

Image display is done by:

void draw(s_int16 x, s_int16 y, drawing_area * da_opt=NULL);

Which draws the image with it's current settings at position (x,y).
Never mind the drawing_area parameter for the moment.

This method should be used when the image's parameter doesn't change
often (or better, they doesn't change at all). Good examples are characters,
which are usually masked but never use translucency. This method should
be preffered in most cases.

Using the putbox functions

Use them when the image's settings are not fixed at load time and you
don't know with which functions it will be drawn. These functions
are used for example in the mapengine ; as the settings are not set
in the pattern structure but each square has it's own translucency/mask
properties.

void image::putbox (s_int16 x, s_int16 y, 

                    drawing_area * da_opt=NULL); 

void image::putbox_mask (s_int16 x, s_int16 y, 

                         drawing_area * da_opt=NULL);

void image::putbox_trans (s_int16 x, s_int16 y, u_int8 a, 

                          drawing_area * da_opt=NULL);

void image::putbox_mask_trans (s_int16 x, s_int16 y, u_int8 a, 

                               drawing_area * da_opt=NULL);

putbox is a simple blitting function, putbox_mask blit the image to
the screen excepted the awfull pink (0xFF00FF) color, while putbox_trans
blits the image with an alpha blending (translucency) effect.

It is not recommended to use the two methods at the same time, although
the putbox functions update the image's settings (i.e after making
a putboxmask the image will have it's mask setting to true and it's
trans setting to 0.

The last one do the contrary of all the functions explained above:

void get_from_screen(s_int16 x, s_int16 y, s_int16 w, s_int16 h);

It will put into your image the portion of the screen located at (x,y)
and of size the current size of your image.

2.1.4 Drawing Areas

Sometimes you may want to display a game scene on a specific part of
the screen (the mapengine is a good example of that). Or you may want
to display semi offscreen images, but you fear the segfault if you
draw outside the screen. The Drawing Areas are simply a rectangle
that is defined by it's position and it's size. Any image can be attached
to a Drawing Area. When attached to a Drawing Area, an image will
ONLY display the part that is INSIDE the Drawing Area.

drawing_area::drawing_area(u_int16 px, u_int16 py, u_int16 pw, u_int16
ph);

void image::assign_drawing_area(drawing_area * da); 

void image::detach_drawing_area();

The Drawing Area optionnal parameter of the putbox functions, when
given and different of NULL, will attach the da_opt Drawing Area for
the blitting operation, then detach it and re-attach the old one (of
attach nothing if there wasn't any).

2.1.5 Special effects

The putbox_img functions do the same thing as the putbox functions
excepted that they will draw into another image.

void putbox_tile_img(image * source); 

void putbox_img(image * source, u_int16 x, u_int16 y); 

void putbox_mask_img (image * source, u_int16 x, u_int16 y); 

void putbox_part_img (image * source, u_int16 x, u_int16 y, 

                      u_int16 bw, u_int16 bh, u_int16 xo, 

                      u_int16 yo);

putbox_tile_img just tile the source image into the image object. The
others should now be familiar ; putbox_part_img is just a bit special
as it allow you to copy only a part of the source image. When using
theses functions, please take care of your image's size!

The two last methods are some graphical effects to use with moderation:

void zoom(image * src); 

void brightness(image * src, u_int16 cont);

Which respectively zoom your source image to the current image's size
and apply a brightness effect to the source image.

2.1.6 Image Edition

The image_edit class allow you to load and save images. Two new methods
are allowed with this class:

s_int8 put(SDL_RWops * file); 

s_int8 save(char * fname);

ONLY use it when you need to save images. This is not only a derivated
class from image with two new methods. It also has to store the raw
image data, which makes its size generally the double of the image
class size would be.([fig] UML Diagram of Image Classes\resizebox*{1\textwidth}{!}{\includegraphics{image.eps}} ) 

2.2 The animation class

The animation is an extension of the image class, allowing several
images to be continuously displayed as, well guess what, an animation
(sometimes you may find docs really assume the reader is an idiot
- but hey, we never know...). It has the same features and possibilities
as the image class.
