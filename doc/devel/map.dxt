/*
   $Id$

   Copyright (C) 2002   Alexandre Courbot
   Part of the Adonthell Project http://adonthell.linuxgames.com

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY.

   See the COPYING file for more details.
*/

/*! 
\page page4 Map Engine Specification

\section mobjs_repr Map Objects Representation

Every object, moveable or not, must have a shape that precisely
describes its occupation. While this shape must allow easy and fast
collision tests against moving %objects to be performed, it also has to
allow complex forms to be described. The most appropriate
representation that matches both requirements is the polygon-based
representation.
 
\subsection mobjs_repr_describe Describing the Shape of Objects with Polygons

A polygon, in the sense we hear it, can actually be understood the
same way as the usual polygon drawing tool that can be found in every
good vectorial drawing software. A polygon is made of a free number of
points, every point being linked to the next one to make a line, and
the last point being linked to the first to make a closed object:

\image latex map_obj_shape.eps "A polygon made of 6 points (and therefore 6 lines)" width=10cm
\image html map_obj_shape.png "A polygon made of 6 points (and therefore 6 lines)"

\subsection mobjs_repr_z_ax Making 3D Objects from 2D Polygons

While the world of Adonthell uses 3D internally, we want to limit the
amount of processing power necessary for each object, to allow as many
of them as possible to live at the same time. For this reason, most of
the arithmetic done by the engine will actually be on 2D shapes that
are extrapolated to form 3D %objects. In addition to its polygonal
shape, an object has a height property, which will make it
extrapolated of as much on the Z axis:

\image latex map_obj_shape.eps "The 2D shape of a map object..." width=10cm
\image html map_obj_shape.png "The 2D shape of a map object..."
\image latex map_obj_shape_extra.eps "...gets extrapolated on the Z axis to form a 3D object." width=10cm
\image html map_obj_shape_extra.png "...gets extrapolated on the Z axis to form a 3D object."

While making an easy way to represent %objects, this method isn't
sufficient to make sloaps and smooth variations of altitude on an
object. Such effect are obtained by considering the polygonal object
itself is inside a square box. Every superior corner of the box can
then be given an offset (either positive or negative), which will make
a sloap from the top shape of the object:

\image latex map_obj_sloap.eps "Sloaps can be created by playing with the height of the englobing box' corners" width=10cm
\image html map_obj_sloap.png "Sloaps can be created by playing with the height of the englobing box' corners"

In practice, this will make it very easy to determine the exact height
of an %object at a given point, by doing a simple interpolation.

\subsection mobjs_repr_collision Collision Detection

A collision detection system is only worth in our case if we can take
care of these two things:
- Wether two polygonal %objects will collide given a displacement vector,
- Where the collision exactly occured, to place the %objects correctly.

The polygonal representation is excellent in that respect, in that it
can solve both problems in a very reasonnable time.

\subsection mobjs_collision_maths Some Maths Used by the Engine

Of course, some geometry concepts have to be used and implemented in
order to get these results. They will be summarized here, with the
same terms that are used in the implementation:

<b>Points</b>

The most basic thing that will be used is the point. I won't make the
offence to explain what is a point - we will simply
describe them with their X, Y (and Z) positions in the space.

<b>Vectors</b>

The first real thing to deal with are vectors. Vectors are widely used
in the map engine, as they represent every displacement of %objects,
but also because every line of our polygons can be considered as a
vector. The representation is nothing to be discussed during hours, a
X, Y, (and Z) displacement values, and voila. The length of a vector
(it's \e norm, noted \f$||u||\f$), is equal to

\f$||u|| = \sqrt{u_x^2 + u_y^2 + u_z^2}\f$
  
In most operations however, we don't need the exact norm of a vector
but we want to know which vector is the longest from a set of vectors.
In this case, we can get rid of the square root.

Another thing we will often need to do is to determine the pointing 
position of two vectors from each another, or the position of a point
from a vector (which is roughly the same). During polygons collision
detection for instance, we can eliminate lines that we don't need to
test if we can determine wether they point in the same direction than
the motion vector or not.

\image latex vectors1.eps "Here, v2 and v3 are pointing in the same direction than v1 (the invert-clockwise angle between them in < 180°)" width=10cm
\image html vectors1.png "Here, v2 and v3 are pointing in the same direction than v1 (the invert-clockwise angle between them in < 180°)"

\image latex vectors2.eps "But here, v2 and v3 are pointing in the opposite direction of v1 (the invert-clockwise angle between them in >= 180°)" width=10cm
\image html vectors2.png "But here, v2 and v3 are pointing in the opposite direction of v1 (the invert-clockwise angle between them in >= 180°)"

In easier words, <i>v points in the same direction than u</i> can be
interpreted as <i>when having the same starting point, v is on u's
left</i>, and <i>v points in the opposite direction of u</i> can be
heard as <i>when having the same starting point, v is on u's
right</i>.

The cross product of two vectors \e u and \e v (noted \f$||u.v||)\f$
can help us knowing if two vectors point in the same
direction. Indeed:

\f$||u.v|| = ||u|| * ||v|| * \sin(\theta)\f$

\f$||u.v|| = u_x * v_y - u_y * v_x\f$

Therefore:

\f$\sin(\theta) = \frac{u_x * v_y - u_y * v_x}{||u|| * ||v||}\f$

The sinus of an invert-clockwise angle will be negative if the angle
is between 0 and 180 degrees (the vectors are pointing in the same
direction), positive otherwise (the vectors are pointing in opposite
directions).

For the engine, we will only need the sign of
\f$\sin(\theta)\f$. Therefore, we can get rid of the division, and
directly consider the sign of the cross-product to know if two vectors
point in the same direction or not.

<b>Lines</b>

Lines, as we hear them, are simply a vector which is given a starting
point. One of the problems we'll have to solve is to know if two lines
intersect, and where?

A first method is to consider the 4 points A, B, C and D. We want to
check wether AB and CD intersect. If they do, then:

\f$A_x + r(B_x - A_x) = C_x + s(D_x - C_x)\f$, and

\f$A_y + r(B_y - A_y) = C_y + s(D_y - C_y)\f$

for \e r and \e s between 0 and 1.

Finding \e r and \e s is as simple as solving:

\f$r = \frac{(A_y - C_y)(D_x - C_x) - (A_x - C_x)(D_y - C_y)}{(B_x - A_x)(D_y - C_y) - (B_y - A_y)(D_x - C_x)}\f$ and

\f$r = \frac{(A_y - C_y)(B_x - A_x) - (A_x - C_x)(B_y - A_y)}{(B_x - A_x)(D_y - C_y) - (B_y - A_y)(D_x - C_x)}\f$.

Note that the denominator is the same - we can save one division by
setting a variable to \f$\frac{1}{denom}\f$ and using multiplications
instead of divisions while calculating \e r and \e s. Moreover,
pre-calculating it is mandatory anyway, as if it is egal to 0 the
lines are parallel and therefore never intersect (and we avoid a
division by 0).

Once we have \e r and \e s, we can assume that if \f$0 <= r <= 1\f$
and \f$0 <= s <= 1\f$, then there actually is an
intersection. Otherwise the lines intersects, but not in the limits
of our segments. We can get the exact coordinates of the intersection
point \e P with:

\f$P_x = A_x + r(B_x - A_x)\f$

\f$P_y = A_y + r(B_y - A_y)\f$

So if used as is, this algorithm will require one float division and four
float multiplications. We can avoir working on floats all the time
because we have a very small unit measure.

<b>FIXME: Try to get rid of all floating operations (by doing some bits
shifting and allowing r and s to be between 0 and 256 for instance)
and of the division.</b>

\subsection polygons_intersection Polygons Intersection

*/
