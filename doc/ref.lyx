#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass docbook-book
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Adonthell Developer Reference
\layout Date

Last updated: 2001/04/28
\layout Author

\begin_deeper 
\layout FirstName

Alexandre
\layout Surname

Courbot
\end_deeper 
\layout Abstract

This document is intended to be the reference both for long-time programmers
 who need informations about a function or a class and for new developers
 willing to have a look at the existing interfaces and classes.
\layout Abstract

This document is written in order to be accessible to new developers, who
 should read it from the beginning.
\layout Chapter


\begin_inset LatexCommand \label{C-Introduction-Concepts}

\end_inset 

Introduction & Concepts
\layout Standard

Allright, ready for a quick tour of what makes Adonthell? Reading this chapter
 will especially be usefull for new developers who want to see what awaits
 for them.
\layout Section


\begin_inset LatexCommand \label{S-Cpp}

\end_inset 

C++
\layout Standard

Adonthell makes intensive use of C++ advantages, when they can make the
 code clear and easier and do not slow things down too much.
 Adonthell tries to respect as much as possible the Object Oriented Programming
 concepts.
 In Adonthell, everything are objects, inheritance and templates are used
 where usefull.
\layout Standard

Also, Adonthell heavily uses some templates from the 
\begin_inset LatexCommand \url[STL C++ library]{http://www.sgi.com/tech/stl/}

\end_inset 


\begin_inset Info
STL url is not correct!
\end_inset 

, especially containers like lists and hash maps, so you'll certainly want
 to give it a look.
\layout Section


\begin_inset LatexCommand \label{S-Python}

\end_inset 

Python
\layout Standard

In many kind of games, including RPGs, a script language is necessary to
 command characters, build complex actions, cutscenes, etc...
 As we want modularity and reusability, in-game actions must be real-time
 interpreted and executed from a script language, which interacts with the
 C++ interface and can of course share variables with it.
 
\begin_inset LatexCommand \url[Python]{http://www.python.org}

\end_inset 

 has proven it was very efficient at this - moreover it's a fully object-oriente
d language which takes into account things like inheritance, and there is
 a great utility, 
\begin_inset LatexCommand \url[SWIG]{http://www.swig.org}

\end_inset 

, which can automate the process of building Python include files from C++
 ones.
 Thanks to the great design of Python, everything in this document that
 applies to the C++ interface also applies to the Python one, making script
 building much easier.
 The only difference is that from Python you can only use one constructor
 - the one that is listed first in the class methods listing.
 Also, operator redefinition isn't supported.
\layout Section


\begin_inset LatexCommand \label{S-Source-code-organisation}

\end_inset 

Source code organisation
\layout Standard

Adonthell make use of 
\emph on 
autoconf
\emph default 
 and 
\emph on 
automake
\emph default 
 to be built.
 Each subdirectory has a 
\emph on 
Makefile.am
\emph default 
 file that describes building rules.
 Running
\emph on 
 
\emph default 

\begin_inset Quotes eld
\end_inset 

automake
\begin_inset Quotes erd
\end_inset 

 in the root directory build 
\emph on 
Makefile.in
\emph default 
 files from 
\emph on 
Makefile.am
\emph default 
 in each subdirectory.
 
\begin_inset Quotes eld
\end_inset 

autoconf
\begin_inset Quotes erd
\end_inset 

 builds the configure script from 
\emph on 
configure.in
\emph default 
.
 Finally, running 
\begin_inset Quotes eld
\end_inset 

./configure
\begin_inset Quotes erd
\end_inset 

 generates all the 
\emph on 
Makefile
\emph default 
s from 
\emph on 
Makefile.in
\emph default 
s, making the package ready for a 
\begin_inset Quotes eld
\end_inset 

make
\begin_inset Quotes erd
\end_inset 

.
\layout Standard

Here is what the source tree does look like:
\layout Description

doc/ The user and developer documentation
\layout Description

src/ Source code for Adonthell engine - this is where the 
\emph on 
adonthell
\emph default 
 executable is built
\begin_deeper 
\layout Description

tools Various development tools
\begin_deeper 
\layout Description

dlgedit The dialogue editor (requires GTK+)
\layout Description

charedit The character editor (requires GTK+)
\layout Description

questedit The quest editor (requires GTK+)
\layout Description

maptools The map building tools
\layout Description

pydonthell A custom Python interpreter with Adonthell Python modules inside
\layout Description

oggloop Ogg music looping utility
\layout Description

combat Tests about fighting rules
\end_deeper 
\end_deeper 
\layout Standard

Each class that is documented here is generally implemented by 
\emph on 
classname.h
\emph default 
 and 
\emph on 
classname.cpp
\emph default 
, unless it is explicitely specified in the class section.
\layout Section

Data types
\layout Standard

Adonthell can run on several platforms, which all have different characteristics.
 One of these differences can reside in the way the basic C types (char,
 ints, ...) are encoded.
 A 32 bits operating system will code it's 
\emph on 
int
\emph default 
s with 32 bits, while a 64 bits operating system will use 64 bits for 
\emph on 
int
\emph default 
s.
 For several operations (like reading an 
\emph on 
int
\emph default 
 from a file) this can result in different behavior, and catastrophic consequenc
es (most likely protection fault).
 That's why some of the most basic types have been redifined according to
 the architecture in 
\emph on 
types.h
\emph default 
:
\layout Itemize

u_int8: unsigned 8 bits integer
\layout Itemize

s_int8: signed 8 bits integer
\layout Itemize

u_int16: unsigned 16 bits integer
\layout Itemize

s_int16: signed 16 bits integer
\layout Itemize

u_int32: unsigned 32 bits integer
\layout Itemize

s_int32: signed 32 bits integer
\begin_inset Info
Types.h only takes x86 architecture into account
\end_inset 


\layout Section

Game dynamic
\layout Standard

As we display animated things, we must know 
\emph on 
when
\emph default 
 they must change.
 A game that runs at a different speed on various machines has nearly no
 interest, as only a few configurations can make it run at the good speed.
 So it's very important to have a timing system built into the game engine.
\layout Standard

Adonthell uses it's own timing system.
 The time unit is the 
\emph on 
game cycle
\emph default 
, which corresponds to approximatively 1/70 of second.
 When the game runs, it performs a loop which looks like this:
\layout Code

while(<condition to quit the engine>)
\layout Code

{
\layout Code

  gametime::update();
\layout Code

  for(i=0;i<gametime::get_frames_to_do();i++)
\layout Code

   {
\layout Code

     <update the game status (character positions,...)>
\layout Code

   }
\layout Code

  <perform drawing operations>
\layout Code

}
\layout Standard

Explanations:
\layout Standard

This loop performs what is necessary to update the screen.
 Depending on the speed of the CPU, this can take more or less time.
 You've seen that a game cycle durate 1/70 of a second.
 For some machines, this is not enough to perform the entire loop.
\layout Standard

As you've seen, there are two kinds of operations that are in the loop:
\layout Itemize

Update operations, which actually update the state of the game, according
 to user input, previous game state, etc...
 These operations are very fast to perform.
\layout Itemize

Drawing operations, that is, update the screen.
 This is what may slow things down.
 Some graphic boards simply can't redraw the entire screen 70 times per
 second.
\layout Standard

So the solution to keep the game running at the same speed on every machine
 is to draw less frames per second on slow machines (instead of drawing
 1 frame every game cycle, we'll draw one frame for 2 games cycles, for
 example).
 This is where gametime is usefull: The 
\emph on 
gametime::update()
\emph default 
 method calculates the delay between the last call and the current call.
 It can then calculate if we've been late, and catch the time back by telling
 to the other objects that we must perform 2 games cycles instead of 1 to
 be sync (this is the result of the 
\emph on 
gametime::get_frames_to_do()
\emph default 
 method).
 For example, if the last loop took 1/35 of a second to be completed, 
\emph on 
gametime::get_frames_to_do()
\emph default 
 will return 2, so the loop will perform 2 game updates before drawing the
 screen.
 On the contrary, if the machine is too fast (if it can draw 2 frames for
 each game cycle, for example), it will 
\emph on 
usleep()
\emph default 
 to stay in sync.
\layout Standard

In a more general manner, 
\emph on 
every
\emph default 
 class that get's updated and draw something on the screen MUST have an
 
\emph on 
update()
\emph default 
 method, that updates it's state 
\emph on 
once
\emph default 
, and a 
\emph on 
draw()
\emph default 
 method to draw it on the screen.
\layout Chapter


\begin_inset LatexCommand \label{C-Initialisation-Cleanup}

\end_inset 

Initialisation & Cleanup
\layout Section


\begin_inset LatexCommand \label{S-The-game-class}

\end_inset 

The game class
\layout Subsection


\begin_inset LatexCommand \label{SS-Game-Description}

\end_inset 

Description
\layout Description

Implemented\SpecialChar ~
in: game.h, game.cpp
\layout Description

Access\SpecialChar ~
method: static
\layout Standard

This class is responsible for game initialisation and finalisation.
 It is static, and needs two parameters which are the arguments passed to
 the program.
 This class has only two methods, however they are critical as they are
 responsible for all the game initialisation and cleanup - so they must
 ABSOLUTELY be called as the first and last functions called in the main
 program.
\layout Standard

Usually you'll never have to call these functions yourself - this class
 is only here for reference.
\layout Subsection


\begin_inset LatexCommand \label{SS-Game-Methods}

\end_inset 

Methods
\layout Standard

They are rather self-explicit:
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>init</function></funcdef>
\layout SGML

<paramdef>int<parameter> argc </parameter> </paramdef>
\layout SGML

<paramdef>char **<parameter> argv</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Read the configuration file, check the validity of the data directory and
 initialize the display, input, sound, data and Python systems.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>cleanup</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Write configuration file and shutdown the display, input, sound, data and
 Python systems.
\layout Chapter


\begin_inset LatexCommand \label{C-Low-level-graphics}

\end_inset 

Low level graphics
\layout Section


\begin_inset LatexCommand \label{S-The-drawing-area-class}

\end_inset 

The drawing_area class
\layout Subsection


\begin_inset LatexCommand \label{SS-Drawing-area-Description}

\end_inset 

Description
\layout Description

Implemented\SpecialChar ~
in: drawing_area.h, drawing_area.cpp
\layout Description

Access\SpecialChar ~
method: dynamic
\layout Standard

During some drawing operation, you may want to limit the blits to a certain
 area of the screen.
 For example, if you want to draw an image into a window, and tha image
 is larger than this window, you don't want the entire image to appear,
 only the part that fits the window.
 This is exactly what drawing areas are for.
 A drawing area is a square that can be any size and located anywhere on
 the screen.
 If you 
\emph on 
assign
\emph default 
 a drawing area to a drawable object (for example, an 
\begin_inset LatexCommand \ref[image]{S-The-image-class}

\end_inset 

), and then draw the image on the screen, the part of the image that doesn't
 fit the drawing area limits isn't displayed.
 A drawing area can be assigned to any drawable, but also to another drawing
 area, in which case the result of blitting operations from object that
 are assigned to the second drawing area will be limited to the intersection
 of the two drawing areas.
\layout Subsection


\begin_inset LatexCommand \label{SS-Drawing-area-Methods}

\end_inset 

Methods
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>drawing_area</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

The default constructor.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>drawing_area</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter> px </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> py </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> pw </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> ph </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Constructor for creating a drawing area of size 
\emph on 
(pw,ph)
\emph default 
 at position 
\emph on 
(px,py)
\emph default 
.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>resize</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter> dl </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> dh </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Resize the drawing area to 
\emph on 
(dl,dh)
\emph default 
.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>move</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter> dx </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> dy </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Move the drawing area to 
\emph on 
(dx,dy)
\emph default 
.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>assign_drawing_area</function></funcdef>
\layout SGML

<paramdef>drawing_area * <parameter> da </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Assign the 
\emph on 
da
\emph default 
 drawing area to this drawing area.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>detach_drawing_area</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Detach the drawing area (if any) previously assigned to this drawing area.
\layout Section


\begin_inset LatexCommand \label{S-The-screen-class}

\end_inset 

The screen class
\layout Subsection


\begin_inset LatexCommand \label{SS-screen-Description}

\end_inset 

Description
\layout Description

Implemented\SpecialChar ~
in: screen.cpp, screen.h
\layout Description

Access\SpecialChar ~
method: static
\layout Standard

This static class sets video modes, 
\begin_inset Info
temporisation done in screen::show() should go
somewhere else (gametime seems a good
candidate)
init_frame_counter should disappear too.
get_frames_to_do should move to gametime too.
\end_inset 

flush the frame buffer to the physical screen and make abstraction of the
 real screen depth to ease the graphic programmer's task.
\layout Subsection


\begin_inset LatexCommand \label{SS-screen-Methods}

\end_inset 

Methods
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>set_video_mode</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter> nl </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> nh </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Sets the video mode at the right depth according to the 
\emph on 
nl
\emph default 
 and 
\emph on 
nh
\emph default 
 parameters.
\layout Description

u_int16\SpecialChar ~
nl: The desired screen resolution's length.
\layout Description

u_int16\SpecialChar ~
nh: The desired screen resolution's height.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>set_fullscreen</function></funcdef>
\layout SGML

<paramdef>bool <parameter> mode </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Sets/unsets fullscreen mode.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>bool <function>get_fullscreen</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns whether fullscreen mode is on or not.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>show</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Copies the screen buffer to the physical screen (actually displays the screen).
 This function must be called after all your graphical operations, when
 you want the changes made to be visibles.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>drawbox</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> y </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> w </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> h </parameter></paramdef>
\layout SGML

<paramdef>u_int32 <parameter> color </parameter></paramdef>
\layout SGML

<paramdef>drawing_area * <parameter> da_opt=NULL </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Draw a box at coordinates 
\emph on 
(x,y)
\emph default 
, of size 
\emph on 
(w,h)
\emph default 
 with the color 
\emph on 
color
\emph default 
, into the (optionnal) drawing_area 
\emph on 
da_opt
\emph default 
.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>clear</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Fills the screen with black.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>set_mouse_cursor_visible</function></funcdef>
\layout SGML

<paramdef>bool <parameter> b </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Enable/disable mouse cursor.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>bool <function>mouse_cursor_visible</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns whether the mouse cursor is visible or not.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int16 <function>get_length</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the screen length, in pixels.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int16 <function>get_height</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the screen height, in pixels.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int32 <function>get_trans_col</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the color that will appear as transparent.
\layout Section


\begin_inset LatexCommand \label{S-The-image-class}

\end_inset 

The image class
\layout Description

Implemented\SpecialChar ~
in: image.cpp, image.h
\layout Description

Access\SpecialChar ~
method: dynamic
\layout Subsection


\begin_inset LatexCommand \label{SS-image-Description}

\end_inset 

Description
\layout Standard


\begin_inset Info
get_pix and put_pix MUST work with hex triplets!
putbox must disappear!
\end_inset 

Designed to work with single images, without having to care about the bit
 depth.
 This class is widely used through the game - in fact it handles everything
 that is displayed on the screen.
\layout Standard

Each image has two parameters - a 
\emph on 
mask
\emph default 
 parameter, defining whether the transparent color ( which hex triplet is
 FF00FF) should be displayed or no, allowing to display images that doesn't
 look like squares, and an 
\emph on 
alpha
\emph default 
 parameter that define the opacity of the image.
 It's a 8 bits large unsigned integer, so correct values for it go from
 0 (invisible) to 255 (totally opaque).
\layout Standard

When compiled with the 
\emph on 
_EDIT_
\emph default 
 flag, image provides lots of other methods for image editing and saving.
\layout Subsection


\begin_inset LatexCommand \label{SS-image-Methods}

\end_inset 

Methods
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>image</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Default constructor, initialize the image so it can safely be used.
 The image's length and height are then 0.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>image</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter> l </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> h </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Creates an image of size 
\emph on 
(l,h)
\emph default 
.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef><function>~image</function></funcdef>
\layout SGML

<paramdef></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Destructor.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>clear</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Erase your image, making it exactly the same as a newly created, (0,0) sized
 image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>resize</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter> l </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> h </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Resize the image to dimensions 
\emph on 
(l,h)
\emph default 
.
 All the content of the image is then lost.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int16 <function>get_length</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the length of the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>get_height</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the height of the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>s_int8 <function>get</function></funcdef>
\layout SGML

<paramdef>gzFile <parameter>file</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Loads an image from an opened file, with it's transparency and alpha parameters.
\layout Description

Return\SpecialChar ~
value:
\begin_deeper 
\layout Itemize

0 in case of success,
\layout Itemize

-1 in case of memory allocation error.
\end_deeper 
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>s_int8 <function>load</function></funcdef>
\layout SGML

<paramdef>const char * <parameter>fname</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Loads an image from a non-opened file, with it's transparency and alpha
 parameters.
\layout Description

Return\SpecialChar ~
value:
\begin_deeper 
\layout Itemize

0 in case of success,
\layout Itemize

-1 in case of memory allocation error.
\end_deeper 
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>s_int8 <function>get_raw</function></funcdef>
\layout SGML

<paramdef>gzFile <parameter>file</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Loads an image from an opened file, without it's transparency and alpha
 parameters.
\layout Description

Return\SpecialChar ~
value:
\begin_deeper 
\layout Itemize

0 in case of success,
\layout Itemize

-1 in case of memory allocation error.
\end_deeper 
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>s_int8 <function>load_raw</function></funcdef>
\layout SGML

<paramdef>const char * <parameter>fname</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Loads an image from a non-opened file, without it's transparency and alpha
 parameters.
\layout Description

Return\SpecialChar ~
value:
\begin_deeper 
\layout Itemize

0 in case of success,
\layout Itemize

-1 in case of memory allocation error.
\end_deeper 
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>s_int8 <function>get_pnm</function></funcdef>
\layout SGML

<paramdef>gzFile <parameter>file</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Loads an image encoded in PNM raw format from an opened file, without it's
 transparency and alpha parameters.
\layout Description

Return\SpecialChar ~
value:
\begin_deeper 
\layout Itemize

0 in case of success,
\layout Itemize

-1 in case of memory allocation error.
\end_deeper 
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>s_int8 <function>load_pnm</function></funcdef>
\layout SGML

<paramdef>const char * <parameter>fname</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Loads an image encoded in PNM raw format from a non-opened file, without
 it's transparency and alpha parameters.
\layout Description

Return\SpecialChar ~
value:
\begin_deeper 
\layout Itemize

0 in case of success,
\layout Itemize

-1 in case of memory allocation error.
\end_deeper 
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>screen_shot</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Takes a screenshot and put it in the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>assign_drawing_area</function></funcdef>
\layout SGML

<paramdef>drawing_area * <parameter>da</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Assign a drawing area to the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>detach_drawing_area</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Detach the drawing area (if any) previously assigned to the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>bool <function>get_mask</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns whether the image is masked or not.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>set_mask</function></funcdef>
\layout SGML

<paramdef>bool <parameter>m</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Sets whether the image is masked or not.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int8 <function>get_alpha</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the alpha parameter of the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>set_alpha</function></funcdef>
\layout SGML

<paramdef>u_int8 <parameter> t </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Sets the alpha parameter of the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>draw</function></funcdef>
\layout SGML

<paramdef>s_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>s_int16 <parameter> y </parameter></paramdef>
\layout SGML

<paramdef>drawing_area * <parameter> da=NULL </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Draw the image at position 
\emph on 
(x,y)
\emph default 
 on the screen, eventually temporarly assigning it to the 
\emph on 
da_opt
\emph default 
 optionnal drawing_area.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>get_from_screen</function></funcdef>
\layout SGML

<paramdef>s_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>s_int16 <parameter> y </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Gets from the screen a shot from coordinates 
\emph on 
(x,y)
\emph default 
 which size is the current size of the image.
\begin_inset Info
screen_shot should just call this function
\end_inset 


\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>zoom</function></funcdef>
\layout SGML

<paramdef>image * <parameter> src </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Zoom the 
\emph on 
src
\emph default 
 image to the dimensions of the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>reserve_lr</function></funcdef>
\layout SGML

<paramdef>image * <parameter> src </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Reverse the 
\emph on 
src 
\emph default 
image horizontally, and put it into the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>reverse_ud</function></funcdef>
\layout SGML

<paramdef>image * <parameter> src </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Reverse the 
\emph on 
src 
\emph default 
image vertically, and put it into the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>brightness</function></funcdef>
\layout SGML

<paramdef>image * <parameter> src </parameter></paramdef>
\layout SGML

<paramdef>s_int16 <parameter> cont </parameter></paramdef>
\layout SGML

<paramdef>bool <parameter> proceed_mask=false </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Brighten the image (actually, darken it if 
\emph on 
cont
\emph default 
 < 32768, brighten it if 
\emph on 
cont
\emph default 
 > 32768), according to the 
\emph on 
cont
\emph default 
 parameter.
 If 
\emph on 
proceed_mask
\emph default 
 is set to true, the transparent color will be brightened too, otherwise
 it won't.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>putbox_tile_img</function></funcdef>
\layout SGML

<paramdef>image * <parameter> source </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Tile the 
\emph on 
source
\emph default 
 img to the img, until it is filled.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>draw_img</function></funcdef>
\layout SGML

<paramdef>image * <parameter> source </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> y </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Does the same as draw(), but instead of drawing on the screen, draw the
 
\emph on 
source 
\emph default 
on the image.
\begin_inset Info
Should take a drawing area argument to make *part* disappear.
\end_inset 


\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>draw_part_img</function></funcdef>
\layout SGML

<paramdef>image * <parameter> source </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter> x </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Draw the 
\emph on 
source
\emph default 
 image to the image, starting at pixel 
\emph on 
(xo,yo)
\emph default 
, and taking an area that is 
\emph on 
(bw,bh)
\emph default 
 sized.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int32 <function>get_pix</function></funcdef>
\layout SGML

<paramdef>s_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>s_int16 <parameter> y </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the pixel at position 
\emph on 
(x,y)
\emph default 
, in screen format.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>put_pix</function></funcdef>
\layout SGML

<paramdef>s_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>s_int16 <parameter> y </parameter></paramdef>
\layout SGML

<paramdef>u_int32 <parameter> col </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Put the 
\emph on 
col
\emph default 
 pixel (in screen format) at position 
\emph on 
(x,y)
\emph default 
.
 
\emph on 
col
\emph default 
 values should ONLY come from returns value of 
\emph on 
image::get_pix()
\emph default 
 and 
\emph on 
screen::get_trans_col()
\emph default 
.
 
\emph on 
put_pix
\emph default 
 and 
\emph on 
get_pix
\emph default 
 are designed to be very fast - however they only allow you to work blindly
 with return values from compatible functions.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int32 <function>get_pix_rgb</function></funcdef>
\layout SGML

<paramdef>s_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>s_int16 <parameter> y </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the pixel at position 
\emph on 
(x,y)
\emph default 
, in RGB format.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>put_pix_rgb</function></funcdef>
\layout SGML

<paramdef>s_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>s_int16 <parameter> y </parameter></paramdef>
\layout SGML

<paramdef>u_int32 <parameter> col </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Put the 
\emph on 
col
\emph default 
 pixel (in RGB format) at position 
\emph on 
(x,y)
\emph default 
.
 
\emph on 
col
\emph default 
 can be built as a 
\emph on 
u_int32
\emph default 
 where the first byte is the red value, the second the green, and the third
 the blue.
 It can be used to accurately modify images - however, it is slower than
 
\emph on 
put_pix 
\emph default 
and should be avoided if possible, excepted if you work with the _EDIT_
 flag enabled and want to save the modified image.
\layout Section


\begin_inset LatexCommand \label{SS-The-animation-class}

\end_inset 

The animation class
\layout Subsection


\begin_inset LatexCommand \label{SS-animation-Description}

\end_inset 

Description
\layout Standard

Most often, you won't use images directly.
 You'll rather want a series of images being displayed one by one, with
 a certain time delay between each image.
 That's exactly what the animation class is designed for.
 An animation contains:
\layout Itemize

A set of images arranged in an indexed array,
\layout Itemize

A set of frame information, also arranged in an indexed array, containing:
\begin_deeper 
\layout Itemize

The number of the image to display when displaying this frame,
\layout Itemize

The 
\emph on 
alpha
\emph default 
 and 
\emph on 
mask
\emph default 
 values for the image,
\layout Itemize

An 
\emph on 
offset
\emph default 
, allowing the image to be accurately placed,
\layout Itemize

The delay (in game cycles) to wait before jumping to the next frame,
\layout Itemize

The number of the next frame to display.
\end_deeper 
\layout Standard

It provides both a high-level and low-level interface.
\layout Subsection


\begin_inset LatexCommand \label{SS-animation-Methods}

\end_inset 

Methods
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>animation</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Default constructor, building a totally empty animation.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef><function>~animation</function></funcdef>
\layout SGML

<paramdef></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Destructor.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>clear</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Empty the animation.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>get_length</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the 
\emph on 
length
\emph default 
 of the animation.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>get_height</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the 
\emph on 
height
\emph default 
 of the animation.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>update</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

State updating function, which must be called for every active animation
 at each game cycle.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>set_active_frame</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter>framenbr</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Directly jumps the the 
\emph on 
framenbr
\emph default 
 frame.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>next_frame</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Directly jumps to the next frame.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>play</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Start the playback of an animation (i.e.
 the animation will play provided 
\emph on 
update()
\emph default 
 is appropriately called).
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>stop</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Stop the playback of an animation (i.e.
 the animation won't play despite of 
\emph on 
update()
\emph default 
 being called).
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>rewind</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Rewind an animation to it's beginning.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int16 <function>get_currentframe</function></funcdef>
\layout SGML

<paramdef>void</paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Returns the index of the frame currently being displayed.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>draw</function></funcdef>
\layout SGML

<paramdef>s_int16 <parameter> x </parameter></paramdef>
\layout SGML

<paramdef>s_int16 <parameter> y </parameter></paramdef>
\layout SGML

<paramdef>drawing_area * <parameter> da_opt=NULL </parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Draw the animation at position 
\emph on 
(x,y)
\emph default 
, eventually temporarly assigning it the 
\emph on 
da_opt
\emph default 
.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>get</function></funcdef>
\layout SGML

<paramdef>gzFile <parameter>file</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Loads an animation from an opened file.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>load</function></funcdef>
\layout SGML

<paramdef>char * <parameter>fname</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Loads an animation from a non-opened file.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>void <function>zoom</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter>sx</parameter></paramdef>
\layout SGML

<paramdef>u_int16 <parameter>sy</parameter></paramdef>
\layout SGML

<paramdef>animation * <parameter>src</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Copy and zoom the 
\emph on 
src
\emph default 
 animation by a factor of 
\emph on 
(src->get_length()/sx,src->get_height()/sy)
\emph default 
.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>animationframe * <function>get_frame</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter>nbr</parameter></paramdef>
\layout SGML

</funcsynopsys>
\layout Standard

Returns a pointer to the 
\emph on 
nbr
\emph default 
 frame, usefull for modifying the frame.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>image * <function>get_image</function></funcdef>
\layout SGML

<paramdef>u_int16 <parameter>nbr</parameter></paramdef>
\layout SGML

</funcsynopsys>
\layout Standard

Returns a pointer to the 
\emph on 
nbr
\emph default 
 image, usefull for modifying the image.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int16 <function>add_image</function></funcdef>
\layout SGML

<paramdef>image * <parameter>im</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Adds the 
\emph on 
im
\emph default 
 image to the animation's images and returns it's index number.
\layout SGML

<funcsynopsis>
\layout SGML

<funcdef>u_int16 <function>add_frame</function></funcdef>
\layout SGML

<paramdef>animationframe <parameter>af</parameter></paramdef>
\layout SGML

</funcsynopsis>
\layout Standard

Adds the 
\emph on 
af
\emph default 
 frame to the animation's frames and returns it's index number.
\layout Subsection

Usage tips
\layout Itemize

You can easily build a looped animation.
 Simply make the last frame points to a previous frame.
\layout Itemize

By setting the frame delay to 0 (infinite), the animation will go to the
 next frame only if you call the 
\emph on 
next_frame()
\emph default 
 method.
 This can be usefull if you want to animate something which duration isn't
 exactly known and defined by events (for example, a jump).
\the_end
